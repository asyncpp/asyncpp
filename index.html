<!-- HTML header for doxygen 1.10.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtmlcharset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Async++: Async++ library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="overrides.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
  DoxygenAwesomeDarkModeToggle.init()
  DoxygenAwesomeFragmentCopyButton.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign">
   <div id="projectname">Async++<span id="projectnumber">&#160unknown</span>
   </div>
   <div id="projectbrief">Async (co_await/co_return) code for C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Async++ library </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__2home_2runner_2work_2asyncpp_2asyncpp_2README"></a><img src="https://raw.githubusercontent.com/asyncpp/asyncpp/master/.github/logo.svg" alt="logo" style="pointer-events: none; max-width:300px;margin-left:auto; margin-right:auto;" width="100%" class="inline"/></p>
<p><a href="https://github.com/asyncpp/asyncpp/blob/master/LICENSE"><img src="https://img.shields.io/github/license/asyncpp/asyncpp" alt="License Badge" class="inline"/></a> <a href="https://github.com/asyncpp/asyncpp/stargazers"><img src="https://img.shields.io/github/stars/asyncpp/asyncpp" alt="Stars Badge" class="inline"/></a></p>
<p>Async++ is a c++ library providing polyfills and a large set of general purpose utilities for making use of c++20 coroutines. It aims to provide modern and easy to use interfaces without sacrificing performance. While it is primarily tested and developed on modern linux, patches and improvements for other platforms are welcome.</p>
<p>Tested and supported compilers: </p><table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Linux   </th><th class="markdownTableHeadNone">Windows   </th><th class="markdownTableHeadNone">MacOS (best effort)    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a href="https://github.com/asyncpp/asyncpp/actions/workflows/compiler-support.yml"><img src="https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/asyncpp/asyncpp/badges/compiler/ubuntu-2404_clang-16/shields.json" alt="ubuntu-2404_clang-16" class="inline"/></a>   </td><td class="markdownTableBodyNone"><a href="https://github.com/asyncpp/asyncpp/actions/workflows/compiler-support.yml"><img src="https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/asyncpp/asyncpp/badges/compiler/windows-2025_msvc17/shields.json" alt="windows-2025_msvc17" class="inline"/></a>   </td><td class="markdownTableBodyNone"><a href="https://github.com/asyncpp/asyncpp/actions/workflows/compiler-support.yml"><img src="https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/asyncpp/asyncpp/badges/compiler/macos-15-arm_clang-18/shields.json" alt="macos-15-arm_clang-18" class="inline"/></a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a href="https://github.com/asyncpp/asyncpp/actions/workflows/compiler-support.yml"><img src="https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/asyncpp/asyncpp/badges/compiler/ubuntu-2404_clang-17/shields.json" alt="ubuntu-2404_clang-17" class="inline"/></a>   </td><td class="markdownTableBodyNone"><a href="https://github.com/asyncpp/asyncpp/actions/workflows/compiler-support.yml"><img src="https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/asyncpp/asyncpp/badges/compiler/windows-2022_msvc17/shields.json" alt="windows-2022_msvc17" class="inline"/></a>   </td><td class="markdownTableBodyNone"><a href="https://github.com/asyncpp/asyncpp/actions/workflows/compiler-support.yml"><img src="https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/asyncpp/asyncpp/badges/compiler/macos-14-arm_clang-15/shields.json" alt="macos-14-arm_clang-15" class="inline"/></a>   </td></tr>
</table>
<p>| <a href="https://github.com/asyncpp/asyncpp/actions/workflows/compiler-support.yml"><img src="https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/asyncpp/asyncpp/badges/compiler/ubuntu-2404_clang-18/shields.json" alt="ubuntu-2404_clang-18" class="inline"/></a> | | <a href="https://github.com/asyncpp/asyncpp/actions/workflows/compiler-support.yml"><img src="https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/asyncpp/asyncpp/badges/compiler/macos-13_clang-15/shields.json" alt="macos-13_clang-15" class="inline"/></a> | | | <a href="https://github.com/asyncpp/asyncpp/actions/workflows/compiler-support.yml"><img src="https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/asyncpp/asyncpp/badges/compiler/ubuntu-2404_gcc-12/shields.json" alt="ubuntu-2404_gcc-12" class="inline"/></a> | | | | <a href="https://github.com/asyncpp/asyncpp/actions/workflows/compiler-support.yml"><img src="https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/asyncpp/asyncpp/badges/compiler/ubuntu-2404_gcc-13/shields.json" alt="ubuntu-2404_gcc-13" class="inline"/></a> | | | | <a href="https://github.com/asyncpp/asyncpp/actions/workflows/compiler-support.yml"><img src="https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/asyncpp/asyncpp/badges/compiler/ubuntu-2404_gcc-14/shields.json" alt="ubuntu-2404_gcc-14" class="inline"/></a> | | | | <a href="https://github.com/asyncpp/asyncpp/actions/workflows/compiler-support.yml"><img src="https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/asyncpp/asyncpp/badges/compiler/ubuntu-2204_clang-13/shields.json" alt="ubuntu-2204_clang-13" class="inline"/></a> | | | | <a href="https://github.com/asyncpp/asyncpp/actions/workflows/compiler-support.yml"><img src="https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/asyncpp/asyncpp/badges/compiler/ubuntu-2204_clang-14/shields.json" alt="ubuntu-2204_clang-14" class="inline"/></a> | | | | <a href="https://github.com/asyncpp/asyncpp/actions/workflows/compiler-support.yml"><img src="https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/asyncpp/asyncpp/badges/compiler/ubuntu-2204_clang-15/shields.json" alt="ubuntu-2204_clang-15" class="inline"/></a> | | | | <a href="https://github.com/asyncpp/asyncpp/actions/workflows/compiler-support.yml"><img src="https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/asyncpp/asyncpp/badges/compiler/ubuntu-2204_gcc-11/shields.json" alt="ubuntu-2204_gcc-11" class="inline"/></a> | | | <a href="https://github.com/asyncpp/asyncpp/actions/workflows/compiler-support.yml"><img src="https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/asyncpp/asyncpp/badges/compiler/ubuntu-2204_gcc-10/shields.json" alt="ubuntu-2204_gcc-10" class="inline"/></a> | |</p>
<p>This library also supports Windows 10 / MSVC; the clang-cl support is, however, still a <a href="https://github.com/llvm/llvm-project/issues/56300">WIP</a>. If possible compatibility with MacOS is ensured, however AppleClang is <em>special</em>.</p>
<p>Also checkout the async wrappers for other libraries:</p><ul>
<li><a href="https://github.com/asyncpp/asyncpp-curl">asyncpp-curl</a></li>
<li><a href="https://github.com/asyncpp/asyncpp-grpc">asyncpp-grpc</a></li>
<li><a href="https://github.com/asyncpp/asyncpp-uring">asyncpp-uring</a></li>
</ul>
<p>The provided tools include:</p><ul>
<li>Types:<ul>
<li>`fire_and_forget_task`</li>
<li>`eager_fire_and_forget_task`</li>
<li>`generator`</li>
<li>`task`</li>
<li>`defer`</li>
<li>`promise`</li>
<li>`single_consumer_event`</li>
<li>`single_consumer_auto_reset_event`</li>
<li>`multi_consumer_event`</li>
<li>`multi_consumer_auto_reset_event`</li>
<li>`mutex`</li>
<li>`latch`</li>
</ul>
</li>
<li>Functions:<ul>
<li>`launch()`</li>
<li>`as_promise()`</li>
</ul>
</li>
<li>Concepts:<ul>
<li>`Dispatcher`</li>
<li>`ByteAllocator`</li>
</ul>
</li>
<li>Utilities:<ul>
<li>`dispatcher`</li>
<li>`async_launch_scope`</li>
<li>Pointer tagging</li>
<li>Reference counting</li>
<li>`scope_guard`</li>
<li>`threadsafe_queue`</li>
<li>Stop tokens</li>
<li>`thread_pool`</li>
<li>`timer`</li>
</ul>
</li>
</ul>
<h1><code>fire_and_forget_task</code></h1>
<p>A coroutine task with void return type that can not be awaited. It can be used as an entrypoint for asynchronous operations started from synchronous code. Coroutines using <code>fire_and_forget_task</code> as a return type are not started automatically and instead provide a <code>start()</code> method for the initial start.</p>
<p>The coroutine function can use <code>co_await</code> to initiate asynchronous operations, but may not return any values other than void or use <code>co_yield</code>.</p>
<p>If an exception propagates outside the coroutine body the default behaviour is to call <code>std::terminate()</code> similar to the behaviour provided by <code>std::thread</code>. This can be changed by awaiting a value of type <code>exception_policy</code>. The library provides two predefined values, <code>exception_policy::terminate</code>, which invokes <code>std::terminate</code> and <code>exception_policy::ignore</code> which ignores the exception and terminates the coroutine as if <code>co_return</code> was invoked inside the function body. The third option is <code>exception_policy::handle(callback)</code> which allows the coroutine to register an arbitrary callback which gets invoke inside the catch block.</p>
<h1><code>eager_fire_and_forget_task</code></h1>
<p>Similar to <code>fire_and_forget_task</code> but execution is immediately started and no <code>start()</code> method is available.</p>
<h1><code>generator&lt;T&gt;</code></h1>
<p>A generator represents a synchronous coroutine returning a sequence of values of a certain type. The coroutine can use <code>co_yield</code> to generate a new value in the returned sequence or end the sequence by returning from the function. However the generator does not support using <code>co_await</code> to wait for an asynchronous operation. <code>generator&lt;T&gt;</code> coroutines serve as a more readable and potentially more performant alternative to custom iterator types. </p><div class="fragment"><div class="line">generator&lt;int&gt; sample_generator(<span class="keywordtype">int</span> max) {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; max; i++)</div>
<div class="line">        <span class="keyword">co_yield</span> i;</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : sample_generator(10))</div>
<div class="line">        std::cout &lt;&lt; e &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p> When a new instance of the coroutine is created the coroutine is initially suspended. Once <code>begin()</code> is called on the returned coroutine it is executed until the first <code>co_yield</code> and resumed every time <code>operator++()</code> is invoked on the iterator type.</p>
<p>Exceptions thrown inside the coroutine will propagate outside <code>begin()</code> or <code>operator++()</code>. Calling <code>begin()</code> multiple times or keeping an iterator beyond the lifetime of the originating coroutine causes undefined behaviour. Dereferencing the iterator returns a reference to the variable passed to <code>co_yield</code> inside the coroutine and might therefore be invalid after advancing the coroutine.</p>
<p>The method <code>end()</code> returns a constant sentinel value and is save to call any number of times.</p>
<h1><code>task&lt;T&gt;</code></h1>
<p>The most fundamental building block for coroutine programs is <code>task&lt;T&gt;</code>. It provides a generic asynchronous coroutine task which serves as an awaitable and can await other awaitables within. It provides a single result of type T and forwards exceptions thrown within to the awaiting coroutine.</p>
<h1><code>defer</code></h1>
<p>The defer class allows switching a coroutine to another dispatcher. This is commonly used for operations that need to be executed on a certain thread or to switch to a thread pool in order to utilize multiple cores better. It accepts any class implementing the <code>Dispatcher</code> concept and schedules the current coroutine for execution on the dispatcher. You can either pass a dispatcher by reference or pointer, where passing a nullpointer will result in a noop. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;asyncpp/defer.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Use inside a coroutine type</span></div>
<div class="line"><span class="keyword">co_await</span> defer{some_dispatcher};</div>
</div><!-- fragment --><h1><code>promise&lt;T&gt;</code></h1>
<p>Async++ provides a generic promise type similar to <code>std::promise&lt;T&gt;</code> but with additional features. You can either <code>reject()</code> a promise with an exception or provide a value using <code>fulfill()</code>. You can also synchronously wait for the promise using <code>get()</code>, which optionally accepts a timeout. Unlike <code>std::promise</code> however you can also register a callback using <code>on_result()</code> which gets executed immediately after a result is available. It also intergrates nicely with coroutines using <code>co_await</code>, which will suspend the current coroutine until a result is provided. Unlike <code>std::promise</code>, theres no distinction between future and promise, meaning anyone with access to the promise can resolve it. </p><h2>Summary</h2>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TResult&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="classasyncpp_1_1promise.html">asyncpp::promise</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">using </span>result_type = TResult;</div>
<div class="line">  <a class="code hl_function" href="classasyncpp_1_1promise.html#a6cd4a70e4b8b6d331444edcc33500152">promise</a>();</div>
<div class="line">  <a class="code hl_function" href="classasyncpp_1_1promise.html#a6cd4a70e4b8b6d331444edcc33500152">promise</a>(<span class="keyword">const</span> <a class="code hl_function" href="classasyncpp_1_1promise.html#a6cd4a70e4b8b6d331444edcc33500152">promise</a>&amp; other);</div>
<div class="line">  <a class="code hl_function" href="classasyncpp_1_1promise.html#a6cd4a70e4b8b6d331444edcc33500152">promise</a>&amp; <a class="code hl_function" href="classasyncpp_1_1promise.html#ad9aaef6795a0f4bce46d674a9c453b5f">operator=</a>(<span class="keyword">const</span> <a class="code hl_function" href="classasyncpp_1_1promise.html#a6cd4a70e4b8b6d331444edcc33500152">promise</a>&amp; other);</div>
<div class="line">  <span class="keywordtype">bool</span> <a class="code hl_function" href="classasyncpp_1_1promise.html#a930584a2a7f9461c9e8a3f543bc1f0c9">is_pending</a>() const noexcept;</div>
<div class="line">  <span class="keywordtype">bool</span> <a class="code hl_function" href="classasyncpp_1_1promise.html#aef2f1f23810d613fdfa2ad18d76bd9a9">is_fulfilled</a>() const noexcept;</div>
<div class="line">  <span class="keywordtype">bool</span> <a class="code hl_function" href="classasyncpp_1_1promise.html#a967f29f8cccdd31416fe04c2c3150765">is_rejected</a>() const noexcept;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classasyncpp_1_1promise.html#a2404e3b28084e0e0ad5bd2660bdb84fa">fulfill</a>(TResult&amp;&amp; value);</div>
<div class="line">  <span class="keywordtype">bool</span> <a class="code hl_function" href="classasyncpp_1_1promise.html#a9fa01af4a8596bf04c2905b93fbc365b">try_fulfill</a>(TResult&amp;&amp; value);</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classasyncpp_1_1promise.html#ad503c6b15dbbc2085ce3893b72466ad5">reject</a>(std::exception_ptr e);</div>
<div class="line">  <span class="keywordtype">bool</span> <a class="code hl_function" href="classasyncpp_1_1promise.html#a9a6d30f8be8091ea9bfe637f1af5554e">try_reject</a>(std::exception_ptr e);</div>
<div class="line">  template&lt;typename TException, typename... Args&gt;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classasyncpp_1_1promise.html#ad503c6b15dbbc2085ce3893b72466ad5">reject</a>(Args&amp;&amp;... args);</div>
<div class="line">  template&lt;typename TException, typename... Args&gt;</div>
<div class="line">  <span class="keywordtype">bool</span> <a class="code hl_function" href="classasyncpp_1_1promise.html#a9a6d30f8be8091ea9bfe637f1af5554e">try_reject</a>(Args&amp;&amp;... args);</div>
<div class="line">  <span class="keywordtype">void</span> on_result(std::function&lt;<span class="keywordtype">void</span>(TResult*, std::exception_ptr)&gt; cb);</div>
<div class="line">  TResult&amp; <a class="code hl_function" href="classasyncpp_1_1promise.html#a9dd1f83fd770bbf3786b3a3c40207acd">get</a>() const;</div>
<div class="line">  TResult* <a class="code hl_function" href="classasyncpp_1_1promise.html#a9dd1f83fd770bbf3786b3a3c40207acd">get</a>(std::chrono::duration timeout) const;</div>
<div class="line">  std::pair&lt;TResult*, std::exception_ptr&gt; <a class="code hl_function" href="classasyncpp_1_1promise.html#ada609da9d8f77f8dee91c41b29bb4bb8">try_get</a>(std::nothrow_t) const noexcept;</div>
<div class="line">  TResult* <a class="code hl_function" href="classasyncpp_1_1promise.html#ada609da9d8f77f8dee91c41b29bb4bb8">try_get</a>() const;</div>
<div class="line">  auto operator co_await() const noexcept;</div>
<div class="line"> </div>
<div class="line">  static <a class="code hl_function" href="classasyncpp_1_1promise.html#a6cd4a70e4b8b6d331444edcc33500152">promise</a> <a class="code hl_function" href="classasyncpp_1_1promise.html#a5ba575d22fa3d366377c6ed169e67a94">make_fulfilled</a>(TResult&amp;&amp; value);</div>
<div class="line">  static <a class="code hl_function" href="classasyncpp_1_1promise.html#a6cd4a70e4b8b6d331444edcc33500152">promise</a> <a class="code hl_function" href="classasyncpp_1_1promise.html#a8b33a4b48b1dcfac7f50cb82dc1d02b1">make_rejected</a>(std::exception_ptr ex);</div>
<div class="line">  template&lt;typename TException, typename... Args&gt;</div>
<div class="line">  static <a class="code hl_function" href="classasyncpp_1_1promise.html#a6cd4a70e4b8b6d331444edcc33500152">promise</a> <a class="code hl_function" href="classasyncpp_1_1promise.html#a8b33a4b48b1dcfac7f50cb82dc1d02b1">make_rejected</a>(Args&amp;&amp;... args);</div>
<div class="line">  template&lt;typename... T&gt;</div>
<div class="line">  static <a class="code hl_function" href="classasyncpp_1_1promise.html#a6cd4a70e4b8b6d331444edcc33500152">promise</a> first(<a class="code hl_function" href="classasyncpp_1_1promise.html#a6cd4a70e4b8b6d331444edcc33500152">promise</a>&lt;T&gt;... args);</div>
<div class="line">  template&lt;typename... T&gt;</div>
<div class="line">  static <a class="code hl_function" href="classasyncpp_1_1promise.html#a6cd4a70e4b8b6d331444edcc33500152">promise</a> first_successful(<a class="code hl_function" href="classasyncpp_1_1promise.html#a6cd4a70e4b8b6d331444edcc33500152">promise</a>&lt;T&gt;... args);</div>
<div class="line">  static <a class="code hl_function" href="classasyncpp_1_1promise.html#a6cd4a70e4b8b6d331444edcc33500152">promise</a>&lt;std::vector&lt;<a class="code hl_function" href="classasyncpp_1_1promise.html#a6cd4a70e4b8b6d331444edcc33500152">promise</a>&lt;TResult&gt;&gt;&gt; all(std::vector&lt;<a class="code hl_function" href="classasyncpp_1_1promise.html#a6cd4a70e4b8b6d331444edcc33500152">promise</a>&lt;TResult&gt;&gt; args);</div>
<div class="line">  static <a class="code hl_function" href="classasyncpp_1_1promise.html#a6cd4a70e4b8b6d331444edcc33500152">promise</a>&lt;std::vector&lt;TResult&gt;&gt; all_values(std::vector&lt;<a class="code hl_function" href="classasyncpp_1_1promise.html#a6cd4a70e4b8b6d331444edcc33500152">promise</a>&lt;TResult&gt;&gt; args);</div>
<div class="line">};</div>
<div class="ttc" id="aclassasyncpp_1_1promise_html"><div class="ttname"><a href="classasyncpp_1_1promise.html">asyncpp::promise</a></div><div class="ttdoc">Promise type that allows waiting for a result in both synchronous and asynchronous code.</div><div class="ttdef"><b>Definition</b> promise.h:124</div></div>
<div class="ttc" id="aclassasyncpp_1_1promise_html_a2404e3b28084e0e0ad5bd2660bdb84fa"><div class="ttname"><a href="classasyncpp_1_1promise.html#a2404e3b28084e0e0ad5bd2660bdb84fa">asyncpp::promise::fulfill</a></div><div class="ttdeci">void fulfill(auto &amp;&amp;value)</div><div class="ttdoc">Fulfill the promise with a value.</div><div class="ttdef"><b>Definition</b> promise.h:177</div></div>
<div class="ttc" id="aclassasyncpp_1_1promise_html_a5ba575d22fa3d366377c6ed169e67a94"><div class="ttname"><a href="classasyncpp_1_1promise.html#a5ba575d22fa3d366377c6ed169e67a94">asyncpp::promise::make_fulfilled</a></div><div class="ttdeci">static promise make_fulfilled(TResult &amp;&amp;value)</div><div class="ttdoc">Get a fufilled promise with the specified value.</div><div class="ttdef"><b>Definition</b> promise.h:343</div></div>
<div class="ttc" id="aclassasyncpp_1_1promise_html_a6cd4a70e4b8b6d331444edcc33500152"><div class="ttname"><a href="classasyncpp_1_1promise.html#a6cd4a70e4b8b6d331444edcc33500152">asyncpp::promise::promise</a></div><div class="ttdeci">promise()</div><div class="ttdoc">Construct a new promise object in its pending state.</div><div class="ttdef"><b>Definition</b> promise.h:133</div></div>
<div class="ttc" id="aclassasyncpp_1_1promise_html_a8b33a4b48b1dcfac7f50cb82dc1d02b1"><div class="ttname"><a href="classasyncpp_1_1promise.html#a8b33a4b48b1dcfac7f50cb82dc1d02b1">asyncpp::promise::make_rejected</a></div><div class="ttdeci">static promise make_rejected(std::exception_ptr exception)</div><div class="ttdoc">Get a rejected promise with the specified exception.</div><div class="ttdef"><b>Definition</b> promise.h:354</div></div>
<div class="ttc" id="aclassasyncpp_1_1promise_html_a930584a2a7f9461c9e8a3f543bc1f0c9"><div class="ttname"><a href="classasyncpp_1_1promise.html#a930584a2a7f9461c9e8a3f543bc1f0c9">asyncpp::promise::is_pending</a></div><div class="ttdeci">bool is_pending() const noexcept</div><div class="ttdoc">Check if the promise is pending.</div><div class="ttdef"><b>Definition</b> promise.h:146</div></div>
<div class="ttc" id="aclassasyncpp_1_1promise_html_a967f29f8cccdd31416fe04c2c3150765"><div class="ttname"><a href="classasyncpp_1_1promise.html#a967f29f8cccdd31416fe04c2c3150765">asyncpp::promise::is_rejected</a></div><div class="ttdeci">bool is_rejected() const noexcept</div><div class="ttdoc">Check if the promise is rejected.</div><div class="ttdef"><b>Definition</b> promise.h:166</div></div>
<div class="ttc" id="aclassasyncpp_1_1promise_html_a9a6d30f8be8091ea9bfe637f1af5554e"><div class="ttname"><a href="classasyncpp_1_1promise.html#a9a6d30f8be8091ea9bfe637f1af5554e">asyncpp::promise::try_reject</a></div><div class="ttdeci">bool try_reject(std::exception_ptr error)</div><div class="ttdoc">Try to reject the promise with an exception.</div><div class="ttdef"><b>Definition</b> promise.h:207</div></div>
<div class="ttc" id="aclassasyncpp_1_1promise_html_a9dd1f83fd770bbf3786b3a3c40207acd"><div class="ttname"><a href="classasyncpp_1_1promise.html#a9dd1f83fd770bbf3786b3a3c40207acd">asyncpp::promise::get</a></div><div class="ttdeci">TResult &amp; get() const</div><div class="ttdoc">Synchronously get the result. If the promise is rejected the rejecting exception gets thrown.</div><div class="ttdef"><b>Definition</b> promise.h:252</div></div>
<div class="ttc" id="aclassasyncpp_1_1promise_html_a9fa01af4a8596bf04c2905b93fbc365b"><div class="ttname"><a href="classasyncpp_1_1promise.html#a9fa01af4a8596bf04c2905b93fbc365b">asyncpp::promise::try_fulfill</a></div><div class="ttdeci">bool try_fulfill(auto &amp;&amp;value)</div><div class="ttdoc">Try to fulfill the promise with a value.</div><div class="ttdef"><b>Definition</b> promise.h:188</div></div>
<div class="ttc" id="aclassasyncpp_1_1promise_html_ad503c6b15dbbc2085ce3893b72466ad5"><div class="ttname"><a href="classasyncpp_1_1promise.html#ad503c6b15dbbc2085ce3893b72466ad5">asyncpp::promise::reject</a></div><div class="ttdeci">void reject(std::exception_ptr error)</div><div class="ttdoc">Reject the promise with an exception.</div><div class="ttdef"><b>Definition</b> promise.h:196</div></div>
<div class="ttc" id="aclassasyncpp_1_1promise_html_ad9aaef6795a0f4bce46d674a9c453b5f"><div class="ttname"><a href="classasyncpp_1_1promise.html#ad9aaef6795a0f4bce46d674a9c453b5f">asyncpp::promise::operator=</a></div><div class="ttdeci">promise &amp; operator=(const promise &amp;other)</div><div class="ttdoc">Copy assignment.</div><div class="ttdef"><b>Definition</b> promise.h:137</div></div>
<div class="ttc" id="aclassasyncpp_1_1promise_html_ada609da9d8f77f8dee91c41b29bb4bb8"><div class="ttname"><a href="classasyncpp_1_1promise.html#ada609da9d8f77f8dee91c41b29bb4bb8">asyncpp::promise::try_get</a></div><div class="ttdeci">TResult * try_get() const</div><div class="ttdoc">Synchronously try get the result. If the promise is rejected the rejecting exception gets thrown.</div><div class="ttdef"><b>Definition</b> promise.h:294</div></div>
<div class="ttc" id="aclassasyncpp_1_1promise_html_aef2f1f23810d613fdfa2ad18d76bd9a9"><div class="ttname"><a href="classasyncpp_1_1promise.html#aef2f1f23810d613fdfa2ad18d76bd9a9">asyncpp::promise::is_fulfilled</a></div><div class="ttdeci">bool is_fulfilled() const noexcept</div><div class="ttdoc">Check if the promise is fulfilled.</div><div class="ttdef"><b>Definition</b> promise.h:156</div></div>
</div><!-- fragment --><h1><code>single_consumer_event</code></h1>
<p>This is similar in concept to a <code>std::condition_variable</code> and allows synchronization between coroutines, as well as normal code and coroutines. If the current coroutine co_await's the event it is suspended until some other coroutine or thread calls <code>set()</code>. If the event is already set when calling co_await the coroutine will directly continue execution in the current thread. If the event is not set, the coroutine gets resumed on the dispatcher that's passed into <code>wait()</code> or inside the call to <code>set()</code> if no dispatcher was provided. The operator co_await will behave as if <code>wait()</code> was called with the result of <code>dispatcher::current()</code>, meaning the coroutine is resumed on the same dispatcher it suspended (not necessarily the same thread, e.g. on a thread pool). If no dispatcher is associated with the current thread it is resumed inside <code>set()</code>. </p><h2>Summary</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_class" href="classasyncpp_1_1single__consumer__event.html">asyncpp::single_consumer_event</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <a class="code hl_function" href="classasyncpp_1_1single__consumer__event.html#aad9beb910e3a893cd9c1db9da899c44a">single_consumer_event</a>(<span class="keywordtype">bool</span> set_initially = <span class="keyword">false</span>) noexcept;</div>
<div class="line">  <span class="keywordtype">bool</span> <a class="code hl_function" href="classasyncpp_1_1single__consumer__event.html#a3695174517dd2d035968ac2a164106a1">is_set</a>() const noexcept;</div>
<div class="line">  <span class="keywordtype">bool</span> <a class="code hl_function" href="classasyncpp_1_1single__consumer__event.html#a3cdfbe57be9b0cbede095682eac52666">is_awaited</a>() const noexcept;</div>
<div class="line">  <span class="keywordtype">bool</span> <a class="code hl_function" href="classasyncpp_1_1single__consumer__event.html#a3a4266f0c4a5cd16dc8ab8ba0ea797a7">set</a>(dispatcher* resume_dispatcher = <span class="keywordtype">nullptr</span>) noexcept;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classasyncpp_1_1single__consumer__event.html#aa670a8afb4533692963f658bd724cc19">reset</a>() noexcept;</div>
<div class="line">  auto operator co_await() noexcept;</div>
<div class="line">  auto <a class="code hl_function" href="classasyncpp_1_1single__consumer__event.html#ae56dbb268457537876221edfd02fa89e">wait</a>(dispatcher* resume_dispatcher = <span class="keywordtype">nullptr</span>) noexcept;</div>
<div class="line">};</div>
<div class="ttc" id="aclassasyncpp_1_1single__consumer__event_html"><div class="ttname"><a href="classasyncpp_1_1single__consumer__event.html">asyncpp::single_consumer_event</a></div><div class="ttdoc">Simple manual reset event supporting a single consumer.</div><div class="ttdef"><b>Definition</b> event.h:30</div></div>
<div class="ttc" id="aclassasyncpp_1_1single__consumer__event_html_a3695174517dd2d035968ac2a164106a1"><div class="ttname"><a href="classasyncpp_1_1single__consumer__event.html#a3695174517dd2d035968ac2a164106a1">asyncpp::single_consumer_event::is_set</a></div><div class="ttdeci">bool is_set() const noexcept</div><div class="ttdoc">Query if the event is currently set.</div><div class="ttdef"><b>Definition</b> event.h:45</div></div>
<div class="ttc" id="aclassasyncpp_1_1single__consumer__event_html_a3a4266f0c4a5cd16dc8ab8ba0ea797a7"><div class="ttname"><a href="classasyncpp_1_1single__consumer__event.html#a3a4266f0c4a5cd16dc8ab8ba0ea797a7">asyncpp::single_consumer_event::set</a></div><div class="ttdeci">bool set(dispatcher *resume_dispatcher=nullptr) noexcept</div><div class="ttdoc">Set the event.</div><div class="ttdef"><b>Definition</b> event.h:62</div></div>
<div class="ttc" id="aclassasyncpp_1_1single__consumer__event_html_a3cdfbe57be9b0cbede095682eac52666"><div class="ttname"><a href="classasyncpp_1_1single__consumer__event.html#a3cdfbe57be9b0cbede095682eac52666">asyncpp::single_consumer_event::is_awaited</a></div><div class="ttdeci">bool is_awaited() const noexcept</div><div class="ttdoc">Query if the event is currently being awaited.</div><div class="ttdef"><b>Definition</b> event.h:51</div></div>
<div class="ttc" id="aclassasyncpp_1_1single__consumer__event_html_aa670a8afb4533692963f658bd724cc19"><div class="ttname"><a href="classasyncpp_1_1single__consumer__event.html#aa670a8afb4533692963f658bd724cc19">asyncpp::single_consumer_event::reset</a></div><div class="ttdeci">void reset() noexcept</div><div class="ttdoc">Reset the event back to unset.</div><div class="ttdef"><b>Definition</b> event.h:83</div></div>
<div class="ttc" id="aclassasyncpp_1_1single__consumer__event_html_aad9beb910e3a893cd9c1db9da899c44a"><div class="ttname"><a href="classasyncpp_1_1single__consumer__event.html#aad9beb910e3a893cd9c1db9da899c44a">asyncpp::single_consumer_event::single_consumer_event</a></div><div class="ttdeci">constexpr single_consumer_event(bool set_initially=false) noexcept</div><div class="ttdoc">Construct a new event.</div><div class="ttdef"><b>Definition</b> event.h:36</div></div>
<div class="ttc" id="aclassasyncpp_1_1single__consumer__event_html_ae56dbb268457537876221edfd02fa89e"><div class="ttname"><a href="classasyncpp_1_1single__consumer__event.html#ae56dbb268457537876221edfd02fa89e">asyncpp::single_consumer_event::wait</a></div><div class="ttdeci">constexpr auto wait(dispatcher *resume_dispatcher=nullptr) noexcept</div><div class="ttdoc">Suspend the current coroutine until the event is set.</div><div class="ttdef"><b>Definition</b> event.h:108</div></div>
</div><!-- fragment --><h1><code>single_consumer_auto_reset_event</code></h1>
<p>Similar to <code>single_consumer_event</code>, but the event is automatically reset if a coroutine is resumed.</p>
<h1><code>multi_consumer_event</code></h1>
<p>Similar to <code>single_consumer_event</code>, but can be awaited by multiple coroutines concurrently. The coroutines are resumed in LIFO order.</p>
<h1><code>multi_consumer_auto_reset_event</code></h1>
<p>Similar to <code>single_consumer_event</code>, but can be awaited by multiple coroutines concurrently. The coroutines are resumed in LIFO order. The event is automatically reset if a coroutine is resumed.</p>
<h1><code>mutex</code></h1>
<p><code>mutex</code> provides a simple mutex that can be used inside coroutines to restrict access to a resource. Locking suspends the current coroutine until the mutex is available again. The <code>mutex</code> does not depend on being unlocked in the same thread it was locked, allowing it to be locked across suspension points that might switch the coroutine to a different thread (like a network request). <code>mutex_lock</code> is a companion class that provides a RAII wrapper similar to <code>std::lock_guard</code>.</p>
<h1><code>latch</code></h1>
<p>An async latch is a synchronization primitive that allows coroutines to asynchronously wait until a counter has been decremented to zero. The latch is a single-use object. Once the counter reaches zero the latch becomes 'ready' and will remain ready until the latch is destroyed. </p><h2>Summary</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span><a class="code hl_class" href="classasyncpp_1_1latch.html">asyncpp::latch</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <a class="code hl_function" href="classasyncpp_1_1latch.html#aca1a96c40f7ea45ebf1fe4de20425715">latch</a>(std::size_t initial) <span class="keyword">noexcept</span>;</div>
<div class="line">  <a class="code hl_function" href="classasyncpp_1_1latch.html#aca1a96c40f7ea45ebf1fe4de20425715">latch</a>(<span class="keyword">const</span> <a class="code hl_function" href="classasyncpp_1_1latch.html#aca1a96c40f7ea45ebf1fe4de20425715">latch</a>&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">  <a class="code hl_function" href="classasyncpp_1_1latch.html#aca1a96c40f7ea45ebf1fe4de20425715">latch</a>&amp; <a class="code hl_function" href="classasyncpp_1_1latch.html#afbde11dcc5d53558bafbd28b7ceef0ae">operator=</a>(<span class="keyword">const</span> <a class="code hl_function" href="classasyncpp_1_1latch.html#aca1a96c40f7ea45ebf1fe4de20425715">latch</a>&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">  <span class="keywordtype">bool</span> <a class="code hl_function" href="classasyncpp_1_1latch.html#a8a968a041664e2ac9845dcf592d680c0">is_ready</a>() const noexcept;</div>
<div class="line">  <span class="keywordtype">void</span> <a class="code hl_function" href="classasyncpp_1_1latch.html#a74680ce6019fefbef42f20e44efc4098">decrement</a>(std::<span class="keywordtype">size_t</span> n = 1) noexcept;</div>
<div class="line">  auto operator co_await() noexcept;</div>
<div class="line">  auto <a class="code hl_function" href="classasyncpp_1_1latch.html#afd0534dd409d5e8d7b4f40630fc11952">wait</a>(dispatcher* resume_dispatcher = <span class="keywordtype">nullptr</span>) noexcept;</div>
<div class="line">};</div>
<div class="ttc" id="aclassasyncpp_1_1latch_html"><div class="ttname"><a href="classasyncpp_1_1latch.html">asyncpp::latch</a></div><div class="ttdoc">The latch class is a downward counter of type std::size_t which can be used to synchronize coroutines...</div><div class="ttdef"><b>Definition</b> latch.h:16</div></div>
<div class="ttc" id="aclassasyncpp_1_1latch_html_a74680ce6019fefbef42f20e44efc4098"><div class="ttname"><a href="classasyncpp_1_1latch.html#a74680ce6019fefbef42f20e44efc4098">asyncpp::latch::decrement</a></div><div class="ttdeci">void decrement(std::size_t n=1) noexcept</div><div class="ttdoc">Decrement the latch counter.</div><div class="ttdef"><b>Definition</b> latch.h:41</div></div>
<div class="ttc" id="aclassasyncpp_1_1latch_html_a8a968a041664e2ac9845dcf592d680c0"><div class="ttname"><a href="classasyncpp_1_1latch.html#a8a968a041664e2ac9845dcf592d680c0">asyncpp::latch::is_ready</a></div><div class="ttdeci">bool is_ready() const noexcept</div><div class="ttdoc">Check if the latch reached zero.</div><div class="ttdef"><b>Definition</b> latch.h:34</div></div>
<div class="ttc" id="aclassasyncpp_1_1latch_html_aca1a96c40f7ea45ebf1fe4de20425715"><div class="ttname"><a href="classasyncpp_1_1latch.html#aca1a96c40f7ea45ebf1fe4de20425715">asyncpp::latch::latch</a></div><div class="ttdeci">latch(std::size_t initial) noexcept</div><div class="ttdoc">Constructs a latch and initializes its internal counter.</div><div class="ttdef"><b>Definition</b> latch.h:25</div></div>
<div class="ttc" id="aclassasyncpp_1_1latch_html_afbde11dcc5d53558bafbd28b7ceef0ae"><div class="ttname"><a href="classasyncpp_1_1latch.html#afbde11dcc5d53558bafbd28b7ceef0ae">asyncpp::latch::operator=</a></div><div class="ttdeci">latch &amp; operator=(const latch &amp;)=delete</div><div class="ttdoc">latch is not copyable</div></div>
<div class="ttc" id="aclassasyncpp_1_1latch_html_afd0534dd409d5e8d7b4f40630fc11952"><div class="ttname"><a href="classasyncpp_1_1latch.html#afd0534dd409d5e8d7b4f40630fc11952">asyncpp::latch::wait</a></div><div class="ttdeci">auto wait(dispatcher *resume_dispatcher=nullptr) noexcept</div><div class="ttdoc">Wait for the counter to reach zero.</div><div class="ttdef"><b>Definition</b> latch.h:53</div></div>
</div><!-- fragment --><h1><code>launch()</code></h1>
<p>Start a coroutine which awaits the provided awaitable. This serves as an optimized version of a coroutine returning <code>eager_fire_and_forget_task</code> that immediately invokes <code>co_await</code> on the awaitable. The main use case is to start new coroutines that continue execution independent of the invoking function.</p>
<h1><code>as_promise()</code></h1>
<p><code>as_promise()</code> allows a user to wrap an arbitrary awaitable in a <code>std::promise</code> and therefore allows one to synchronously wait for it.</p>
<h1><code>Dispatcher</code> Concept</h1>
<p>A <code>Dispatcher</code> is a class used by async++ to schedule an action for later execution. The interface consists of a method <code>push()</code> that accepts a value of type <code>std::function&lt;void()&gt;</code>, which is checked by this concept. You can use for example <code>defer</code> to schedule a coroutine on a different dispatcher and most I/O frameworks provide custom dispatchers. Examples would be thread pools, libcurl's multi executor, grpc's event loop or a gui main thread.</p>
<h1><code>ByteAllocator</code> Concept</h1>
<p>A <code>ByteAllocator</code> is an allocator providing memory of type <code>std::byte</code> to the caller. It is used whenever async++ needs to get temporary dynamic memory and for allocating coroutine frames. Most of the functions and classes for interacting with coroutines are allocator aware and accept a custom allocator as the last argument, in order to control how and where memory is allocated. The concept is satisfied if <code>std::allocator_traits&lt;Allocator&gt;::allocate()</code> returns a type thats convertible to <code>std::byte*</code> and <code>std::allocator_traits&lt;Allocator&gt;::deallocate()</code> accepts a <code>std::byte*</code> as the pointer.</p>
<h1><code>dispatcher</code></h1>
<p>This is a base class for dispatcher types. It provides virtual methods implementing the <code>Dispatcher</code> concept. In addition it provides a static <code>current()</code> method that gives you the dispatcher currently executing the coroutine or a nullptr if theres none. This dispatcher can be passed to <code>defer</code> to switch between dispatchers. All async++ provided executors/dispatchers implement this support and 3rd party ones are encouraged to do as well.</p>
<h1><code>async_launch_scope</code></h1>
<p><code>async_launch_scope</code> provides a holder class that groups a number of coroutines together and allows a parent coroutine to wait until all of them have finished processing. A good example for this would be a tcp server that starts a new coroutine for each incoming connection. Using <code>async_launch_scope</code> the parent coroutine can use <code>scope.spawn(awaitable)</code> to start the client coroutines and keep track of them. Once the server receives a shutdown signal it can use the awaitable returned from <code>scope.join()</code> to wait until all of them have finished. This is similar to joining a <code>std::thread</code>. Note that when destructing the scope the number of running coroutines needs to be zero. This can be achieved by <code>co_await</code>ing the <code>join()</code> function or making sure all coroutines returned using some other way.</p>
<h1>Pointer tagging</h1>
<p>Async++ provides support for tagging pointer values by inserting a numeric ID into the unused bits of a pointer. In C++ each type has a certain alignment. As a result of this a pointer to a valid object of said type will always have its lowest bits cleared. Pointer tagging uses these bits and inserts a user specified value. Since the alignment is a compiletime constant value it is possible to later split the pointer back into the original pointer and ID. A common use case for this is passing a handler object to multiple C style operations.</p>
<h1>Reference counting</h1>
<p>Async++ provides a highly customizable intrusive reference counting library with support for seamlessly integrating the reference count often built into C api's and wrapping them in C++ RAII types providing exception safety and ease of use.</p>
<h1><code>scope_guard</code></h1>
<p><code>scope_guard</code> is a RAII type that allows executing a custom callback when a scope exits.</p>
<h1><code>threadsafe_queue&lt;T&gt;</code></h1>
<p><code>threadsafe_queue&lt;T&gt;</code> is a generic threadsafe queue which provides atomic pop and push operations to allow easy implementation of multithreading.</p>
<h1>Stop tokens</h1>
<p>Async++ provides an implementation of the <code>stop_token</code> header in order to support the functionality on libc++ based systems (like MacOS). If the header is natively supported by the used stl the provided types are an alias for the <code>std</code> implementation in order to increase compatibility.</p>
<h1><code>thread_pool</code></h1>
<p><code>thread_pool</code> is a dynamic pool of threads that can be resized at runtime and implements the <code>dispatcher</code> interface. By default each of the threads has its own queue to reduce locking overhead, but other threads can steal work if they run dry.</p>
<h1><code>timer</code></h1>
<p><code>timer</code> implements a simple timer thread that allows scheduling a callback at a specified time. It also enables a coroutine to wait in asynchronously and supports cancellation of callbacks/coroutine waits. It also implements the <code>dispatcher</code> interface.</p>
<h1>Compatibility with shared objects / dll</h1>
<p><code>asyncpp</code> uses static thread_local objects in some places. Currently those are</p><ul>
<li><code>dispatcher</code> To provide the <code>dispatcher::current()</code> method</li>
<li><code>fiber</code> To allow access to the current fiber from within that fiber.</li>
</ul>
<p>Because on most systems static inline variables can exist multiple times when shared libraries are used special care must be taken when this is the case. <code>asyncpp</code> provides a special preprocessor flag <code>ASYNCPP_SO_COMPAT</code> to help with this issue, When this flag is defined it turns all static inline variables into regular static variables that lack a definition, turning them into a unresolved symbol inside the shared object. You can provide this definition by defining a second macro <code>ASYNCPP_SO_COMPAT_IMPL</code> and including the relevant header files (currently only <code><a class="el" href="dispatcher_8h_source.html">dispatcher.h</a></code>). Make sure you only do this in a single file inside the host application or you might get multiple definition errors. In addition to defining the macros above manually theres is also a cmake option <code>ASYNCPP_SO_COMPAT</code>, which when enabled, defines <code>ASYNCPP_SO_COMPAT</code> in all targets that link to asyncpp. As always when using C++ constructs in multiple shared libraries special care must be take that all of them use compatible (ideally identical) versions of asyncpp. </p>
</div></div><!-- PageDoc -->
<a href="doxygen_crawl.html"/>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
