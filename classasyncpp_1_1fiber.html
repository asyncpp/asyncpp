<!-- HTML header for doxygen 1.10.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtmlcharset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Async++: asyncpp::fiber&lt; TReturn &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="overrides.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
  DoxygenAwesomeDarkModeToggle.init()
  DoxygenAwesomeFragmentCopyButton.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.svg"/></td>
  <td id="projectalign">
   <div id="projectname">Async++<span id="projectnumber">&#160unknown</span>
   </div>
   <div id="projectbrief">Async (co_await/co_return) code for C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classasyncpp_1_1fiber.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classasyncpp_1_1fiber-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">asyncpp::fiber&lt; TReturn &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Fiber class providing a stackfull coroutine.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="fiber_8h_source.html">asyncpp/fiber.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad56fe1cfb06e348b024f0a349539adbf" id="r_ad56fe1cfb06e348b024f0a349539adbf"><td class="memTemplParams" colspan="2">template&lt;typename FN &gt; <br />
requires (!std::is_same_v&lt;FN, <a class="el" href="classasyncpp_1_1fiber.html">fiber</a>&gt;)</td></tr>
<tr class="memitem:ad56fe1cfb06e348b024f0a349539adbf"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad56fe1cfb06e348b024f0a349539adbf">fiber</a> (FN &amp;&amp;function, size_t stack_size=262144)</td></tr>
<tr class="memdesc:ad56fe1cfb06e348b024f0a349539adbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new fiber for the specified entry function.  <br /></td></tr>
<tr class="separator:ad56fe1cfb06e348b024f0a349539adbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b0f178d3c84ab206e6bef468bc1faa" id="r_a22b0f178d3c84ab206e6bef468bc1faa"><td class="memItemLeft" align="right" valign="top"><a id="a22b0f178d3c84ab206e6bef468bc1faa" name="a22b0f178d3c84ab206e6bef468bc1faa"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><b>fiber</b> () noexcept=default</td></tr>
<tr class="memdesc:a22b0f178d3c84ab206e6bef468bc1faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty fiber handle. <br /></td></tr>
<tr class="separator:a22b0f178d3c84ab206e6bef468bc1faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87b78e52da1022c124cdfc01ce55755" id="r_af87b78e52da1022c124cdfc01ce55755"><td class="memItemLeft" align="right" valign="top"><a id="af87b78e52da1022c124cdfc01ce55755" name="af87b78e52da1022c124cdfc01ce55755"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>fiber</b> (<a class="el" href="classasyncpp_1_1fiber.html">fiber</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:af87b78e52da1022c124cdfc01ce55755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. The moved from handle will be empty. <br /></td></tr>
<tr class="separator:af87b78e52da1022c124cdfc01ce55755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db1c61e31c66ebdff543ae3a090a2f7" id="r_a4db1c61e31c66ebdff543ae3a090a2f7"><td class="memItemLeft" align="right" valign="top"><a id="a4db1c61e31c66ebdff543ae3a090a2f7" name="a4db1c61e31c66ebdff543ae3a090a2f7"></a>
<a class="el" href="classasyncpp_1_1fiber.html">fiber</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classasyncpp_1_1fiber.html">fiber</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a4db1c61e31c66ebdff543ae3a090a2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor. The moved from handle will be empty. <br /></td></tr>
<tr class="separator:a4db1c61e31c66ebdff543ae3a090a2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c425cdd87a5242bcac23d07a665e46" id="r_a21c425cdd87a5242bcac23d07a665e46"><td class="memItemLeft" align="right" valign="top"><a id="a21c425cdd87a5242bcac23d07a665e46" name="a21c425cdd87a5242bcac23d07a665e46"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>fiber</b> (const <a class="el" href="classasyncpp_1_1fiber.html">fiber</a> &amp;)=delete</td></tr>
<tr class="separator:a21c425cdd87a5242bcac23d07a665e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa543b5f3e3b4105046bedab408f15fd4" id="r_aa543b5f3e3b4105046bedab408f15fd4"><td class="memItemLeft" align="right" valign="top"><a id="aa543b5f3e3b4105046bedab408f15fd4" name="aa543b5f3e3b4105046bedab408f15fd4"></a>
<a class="el" href="classasyncpp_1_1fiber.html">fiber</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classasyncpp_1_1fiber.html">fiber</a> &amp;)=delete</td></tr>
<tr class="separator:aa543b5f3e3b4105046bedab408f15fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8483dfd4d3d60b5f4bce0a4972732208" id="r_a8483dfd4d3d60b5f4bce0a4972732208"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8483dfd4d3d60b5f4bce0a4972732208">await</a> () &amp;</td></tr>
<tr class="memdesc:a8483dfd4d3d60b5f4bce0a4972732208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an awaitable for this fiber.  <br /></td></tr>
<tr class="separator:a8483dfd4d3d60b5f4bce0a4972732208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453455b341163276158802d362de9e12" id="r_a453455b341163276158802d362de9e12"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a453455b341163276158802d362de9e12">await</a> () &amp;&amp;</td></tr>
<tr class="memdesc:a453455b341163276158802d362de9e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an awaitable for this fiber.  <br /></td></tr>
<tr class="separator:a453455b341163276158802d362de9e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afceb038ff4c47ba59b9d790484e63480" id="r_afceb038ff4c47ba59b9d790484e63480"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afceb038ff4c47ba59b9d790484e63480">operator co_await</a> () &amp;</td></tr>
<tr class="memdesc:afceb038ff4c47ba59b9d790484e63480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an awaitable for this fiber.  <br /></td></tr>
<tr class="separator:afceb038ff4c47ba59b9d790484e63480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6fd7bc82c583ac450a90dd2dd4bf79" id="r_a0a6fd7bc82c583ac450a90dd2dd4bf79"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a6fd7bc82c583ac450a90dd2dd4bf79">operator co_await</a> () &amp;&amp;</td></tr>
<tr class="memdesc:a0a6fd7bc82c583ac450a90dd2dd4bf79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an awaitable for this fiber.  <br /></td></tr>
<tr class="separator:a0a6fd7bc82c583ac450a90dd2dd4bf79"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a08117b94069ce097792b4638113d1ff9" id="r_a08117b94069ce097792b4638113d1ff9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a08117b94069ce097792b4638113d1ff9"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a08117b94069ce097792b4638113d1ff9">fiber_await</a> (T &amp;&amp;awaiter)</td></tr>
<tr class="memdesc:a08117b94069ce097792b4638113d1ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Await a standard C++20 coroutine awaitable.  <br /></td></tr>
<tr class="separator:a08117b94069ce097792b4638113d1ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename TReturn&gt;<br />
class asyncpp::fiber&lt; TReturn &gt;</div><p>Fiber class providing a stackfull coroutine. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad56fe1cfb06e348b024f0a349539adbf" name="ad56fe1cfb06e348b024f0a349539adbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad56fe1cfb06e348b024f0a349539adbf">&#9670;&#160;</a></span>fiber()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TReturn &gt; </div>
<div class="memtemplate">
template&lt;typename FN &gt; <br />
requires (!std::is_same_v&lt;FN, <a class="el" href="classasyncpp_1_1fiber.html">fiber</a>&gt;)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classasyncpp_1_1fiber.html">asyncpp::fiber</a>&lt; TReturn &gt;::fiber </td>
          <td>(</td>
          <td class="paramtype">FN &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>function</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>stack_size</em><span class="paramdefsep"> = </span><span class="paramdefval">262144</span></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new fiber for the specified entry function. </p>
<p>The specified function gets placed as the first function in the backtrace of the fiber and is invoked on its own stack once the fiber is awaited. Once the entry function returns a coroutine awaiting the fiber will resume. You can freely specify the stack size and it will get rounded to the next possible value after adding all overhead (guard pages). Keep in mind that most platforms treat exceeding the stack space like a segmentation fault and will terminate your program. This stack_size is a final amount, unlike the normal thread stack it does not grow automatically. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>The function to execute when the fiber is started. </td></tr>
    <tr><td class="paramname">stack_size</td><td>The requested stack size in bytes. This value is rounded up to the next page size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FN</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8483dfd4d3d60b5f4bce0a4972732208" name="a8483dfd4d3d60b5f4bce0a4972732208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8483dfd4d3d60b5f4bce0a4972732208">&#9670;&#160;</a></span>await() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TReturn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classasyncpp_1_1fiber.html">asyncpp::fiber</a>&lt; TReturn &gt;::await </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an awaitable for this fiber. </p>
<dl class="section return"><dt>Returns</dt><dd>auto An awaiter that is resumed once the fiber finishes </dd></dl>

</div>
</div>
<a id="a453455b341163276158802d362de9e12" name="a453455b341163276158802d362de9e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453455b341163276158802d362de9e12">&#9670;&#160;</a></span>await() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TReturn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classasyncpp_1_1fiber.html">asyncpp::fiber</a>&lt; TReturn &gt;::await </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an awaitable for this fiber. </p>
<dl class="section return"><dt>Returns</dt><dd>auto An awaiter that is resumed once the fiber finishes </dd></dl>

</div>
</div>
<a id="a08117b94069ce097792b4638113d1ff9" name="a08117b94069ce097792b4638113d1ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08117b94069ce097792b4638113d1ff9">&#9670;&#160;</a></span>fiber_await()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TReturn &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto <a class="el" href="classasyncpp_1_1fiber.html">asyncpp::fiber</a>&lt; TReturn &gt;::fiber_await </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>awaiter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Await a standard C++20 coroutine awaitable. </p>
<p>Pauses the fiber till the awaited coroutine is done and returns the value generated by it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">awaiter</td><td>The awaitable to await </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value generated by the awaitable </dd></dl>

</div>
</div>
<a id="afceb038ff4c47ba59b9d790484e63480" name="afceb038ff4c47ba59b9d790484e63480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afceb038ff4c47ba59b9d790484e63480">&#9670;&#160;</a></span>operator co_await() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TReturn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classasyncpp_1_1fiber.html">asyncpp::fiber</a>&lt; TReturn &gt;::operator co_await </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> &amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an awaitable for this fiber. </p>
<dl class="section return"><dt>Returns</dt><dd>auto An awaiter that is resumed once the fiber finishes </dd></dl>

</div>
</div>
<a id="a0a6fd7bc82c583ac450a90dd2dd4bf79" name="a0a6fd7bc82c583ac450a90dd2dd4bf79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a6fd7bc82c583ac450a90dd2dd4bf79">&#9670;&#160;</a></span>operator co_await() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TReturn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classasyncpp_1_1fiber.html">asyncpp::fiber</a>&lt; TReturn &gt;::operator co_await </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> &amp;&amp;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an awaitable for this fiber. </p>
<dl class="section return"><dt>Returns</dt><dd>auto An awaiter that is resumed once the fiber finishes </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>asyncpp/<a class="el" href="fiber_8h_source.html">fiber.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>asyncpp</b></li><li class="navelem"><a class="el" href="classasyncpp_1_1fiber.html">fiber</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
